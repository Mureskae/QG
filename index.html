<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quantum of Gratitude — MVP (Full)</title>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Orbitron:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    /*
      Полный стиль интерфейса.
      UI тёмный, минималистичный, область сферы — справа/сверху.
    */
    :root{
      --bg:#07101a;
      --card:#0f1620;
      --accent:#00eaff;
      --accent2:#8f00ff;
      --muted:#9aa6b2;
      --glass: rgba(255,255,255,0.04);
      --glass-2: rgba(255,255,255,0.02);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#021018 80%);color:#e6eef6;font-family:Inter,Segoe UI,Roboto,Arial;-webkit-font-smoothing:antialiased}
    .page{max-width:1180px;margin:18px auto;padding:18px}
    header{display:flex;align-items:center;gap:18px;margin-bottom:14px}
    h1{font-family:'Orbitron',sans-serif;color:var(--accent2);margin:0;font-size:20px}
    .subtitle{color:var(--muted);font-size:13px;margin-top:2px}
    .layout{display:grid;grid-template-columns: 420px 1fr;gap:14px;align-items:start}
    .card{background:linear-gradient(180deg,var(--card),#071018);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 40px rgba(0,0,0,0.6)}
    /* left column UI */
    .panel{display:flex;flex-direction:column;gap:12px}
    .section-title{font-weight:700;color:var(--accent);font-family:'Orbitron',sans-serif;font-size:13px}
    .small{font-size:13px;color:var(--muted)}
    .muted{color:var(--muted)}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{background:linear-gradient(90deg,var(--accent),var(--accent2));border:none;padding:10px 12px;border-radius:8px;color:#031018;font-weight:700;cursor:pointer}
    button.ghost{background:linear-gradient(90deg,#444,#666);color:#fff}
    input[type="text"], select{width:100%;padding:10px;border-radius:8px;border:none;color:#031018}
    label.field{display:flex;flex-direction:column;gap:6px}
    .tokens-row{display:flex;gap:8px}
    .token-box{flex:1;padding:10px;border-radius:10px;background:linear-gradient(90deg,rgba(255,255,255,0.01),rgba(255,255,255,0.02));text-align:center}
    .token-box b{display:block;font-size:14px;margin-bottom:6px}
    .token-value{font-weight:700;font-size:16px}
    .wallet-row{display:flex;gap:8px;align-items:center}
    .note{font-size:12px;color:var(--muted)}
    .footer-note{font-size:12px;color:var(--muted);margin-top:6px}
    /* right column: 3D area */
    .scene-wrap{position:relative;min-height:540px;border-radius:12px;overflow:hidden}
    #threeRoot{position:absolute;left:0;top:0;right:0;bottom:0;display:block}
    #overlayUI{position:absolute;left:18px;top:18px;z-index:10;pointer-events:none}
    #overlayUI .clock{pointer-events:auto}
    .clock{font-family:'Orbitron',sans-serif;color:var(--accent);font-size:20px;letter-spacing:1px;padding:6px 10px;border-radius:8px;background:linear-gradient(90deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));backdrop-filter: blur(6px)}
    /* info panel on top-right */
    .top-info{position:absolute;right:18px;top:18px;z-index:10;pointer-events:auto}
    .top-card{background:linear-gradient(180deg,rgba(0,0,0,0.35),rgba(0,0,0,0.2));padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.02)}
    /* responsive */
    @media (max-width:980px){
      .layout{grid-template-columns:1fr;gap:10px}
      .scene-wrap{min-height:420px}
    }
    /* QR preview */
    #qrPreview{width:100%;height:120px;background:linear-gradient(180deg,#07111a,#041018);display:flex;align-items:center;justify-content:center;color:var(--muted);border-radius:8px;border:1px dashed rgba(255,255,255,0.03)}
    /* send button style */
    .send-btn{background:linear-gradient(90deg,#4caf50,#81c784);color:#031018}
    /* helper for debug panel details */
    .debug{font-size:12px;color:var(--muted);white-space:pre-wrap}
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div>
        <h1>Quantum of Gratitude — MVP</h1>
        <div class="subtitle">QG — model demo. All collected data is anonymized (no personal identifiers).</div>
      </div>
    </header>

    <main class="layout">
      <!-- LEFT: controls -->
      <aside class="panel">
        <section class="card">
          <div class="section-title">Controls</div>
          <div style="display:flex;gap:8px;margin-top:10px">
            <button id="startBtn">Start Tracking</button>
            <button id="stopBtn" class="ghost">Stop</button>
            <button id="sendNowBtn" class="send-btn">Send</button>
          </div>
          <div class="note" style="margin-top:8px">Start — emulate presence and accumulate tokens. Stop — pause accumulation (time runs).</div>
        </section>

        <section class="card">
          <div class="section-title">Tokens</div>
          <div class="small" style="margin-top:8px">Realtime accumulation (demo). Tokens are anonymized and local — for real deployment connect backend.</div>
          <div class="tokens-row" style="margin-top:10px">
            <div class="token-box"><b>RT</b><div class="token-value" id="rtNum">0.000</div></div>
            <div class="token-box"><b>GT</b><div class="token-value" id="gtNum">0.000</div></div>
            <div class="token-box"><b>BT</b><div class="token-value" id="btNum">0.000</div></div>
          </div>

          <div style="margin-top:12px">
            <div class="small">Balances (wallet view)</div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <div style="flex:1;background:var(--glass);padding:8px;border-radius:8px;text-align:center">
                <div class="small">RT</div>
                <div id="balRT" style="font-weight:700">0.000</div>
              </div>
              <div style="flex:1;background:var(--glass);padding:8px;border-radius:8px;text-align:center">
                <div class="small">GT</div>
                <div id="balGT" style="font-weight:700">0.000</div>
              </div>
              <div style="flex:1;background:var(--glass);padding:8px;border-radius:8px;text-align:center">
                <div class="small">BT</div>
                <div id="balBT" style="font-weight:700">0.000</div>
              </div>
            </div>
          </div>
        </section>

        <section class="card">
          <div class="section-title">Wallet</div>
          <div class="wallet-row" style="margin-top:10px;gap:10px;align-items:center">
            <div style="flex:1">
              <div class="small">Address</div>
              <label class="field">
                <input type="text" id="walletInput" placeholder="Paste or scan address (anonymous)"/>
              </label>
            </div>
          </div>

          <div style="margin-top:8px">
            <div class="small">Network</div>
            <select id="networkSelect" style="margin-top:6px">
              <option value="eth">Ethereum</option>
              <option value="polygon">Polygon</option>
              <option value="bsc">BSC</option>
              <option value="near">NEAR</option>
              <option value="sol">Solana</option>
            </select>
          </div>

          <div style="margin-top:10px;display:flex;gap:8px">
            <button id="connectBtn">Connect Wallet</button>
            <button id="scanQRBtn" class="ghost">Scan QR</button>
          </div>

          <div style="margin-top:10px">
            <div id="qrPreview">QR preview / camera capture will appear here</div>
          </div>

          <div class="note" style="margin-top:8px">Demo: Connect toggles anonymous address. Scan opens file picker (QR image) — demo only.</div>
        </section>

        <section class="card">
          <div class="section-title">Debug / Info</div>
          <div class="debug" id="debugBlock" style="margin-top:8px">State: idle</div>
        </section>
      </aside>

      <!-- RIGHT: 3D scene -->
      <section class="scene-wrap card" aria-hidden="false">
        <div id="threeRoot"></div>

        <!-- overlay UI -->
        <div id="overlayUI">
          <div class="clock" id="timeClock">—</div>
        </div>

        <div class="top-info">
          <div class="top-card">
            <div class="small">LightHash</div>
            <div id="lightHash" style="font-weight:700;margin-top:6px">—</div>
          </div>
        </div>

      </section>
    </main>
  </div>

  <!-- three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <!-- optional: GLTFLoader or OrbitControls not strictly needed, skip for smaller bundle -->

  <script>
  /* ----------------------------------------------------------------------------
     Full app logic below.
     - Long, commented implementation of:
         • QG Time Engine
         • Token accumulation (emulation)
         • Glassy iridescent sphere (shader)
         • Particles background
         • UI controls: start/stop, connect wallet, scan QR (demo), send
     - All data remains local/anonymized in this demo.
     ---------------------------------------------------------------------------- */

  (function(){
    // -------------------------
    // Utility helpers
    // -------------------------
    const $ = (id)=>document.getElementById(id);
    function clamp(v,a=0,b=1){ return Math.max(a,Math.min(b,v)); }
    function nowMs(){ return performance.now(); }

    // -------------------------
    // QG Time Engine (alternative time)
    // returns object {hour,part,dola,mgn,mig,sig}
    // -------------------------
    function computeQGTimeFromMs(ms){
      // ms: milliseconds since epoch
      const seconds = ms / 1000;
      const hourLen = 90 * 60; // 5400 s
      const hour = Math.floor(seconds / hourLen) % 24;
      let rem = seconds % hourLen;
      const partLen = 37.5;
      const part = Math.floor(rem / partLen);
      rem = rem % partLen;
      const dolaLen = 2.9;
      const dola = Math.floor(rem / dolaLen);
      rem = rem % dolaLen;
      const mgnLen = 0.4;
      const mgn = Math.floor(rem / mgnLen);
      rem = rem % mgnLen;
      const migLen = 0.006;
      const mig = Math.floor(rem / migLen);
      rem = rem % migLen;
      const sigLen = 0.000064;
      const sig = Math.floor(rem / sigLen);
      return {hour,part,dola,mgn,mig,sig};
    }
    function pad(v,len=2){ let s = String(v); while(s.length<len) s='0'+s; return s; }
    function qgTimeString(){
      const t = computeQGTimeFromMs(Date.now());
      return `${pad(t.hour,2)}.${pad(t.part,3)}.${pad(t.dola,4)}.${pad(t.mgn,4)}.${pad(t.mig,4)}.${pad(t.sig,5)}`;
    }

    // -------------------------
    // App state
    // -------------------------
    const State = {
      running: false,          // accumulation running
      rt: 0, gt: 0, bt: 0,     // accumulated tokens in session
      wallet: 'anonymous',
      network: 'eth',
      lightParts: [],         // recent lighthash parts
      debug: '',
    };

    // -------------------------
    // DOM refs
    // -------------------------
    const rtNum = $('rtNum'), gtNum = $('gtNum'), btNum = $('btNum');
    const balRT = $('balRT'), balGT = $('balGT'), balBT = $('balBT');
    const startBtn = $('startBtn'), stopBtn = $('stopBtn'), sendNowBtn = $('sendNowBtn');
    const connectBtn = $('connectBtn'), scanQRBtn = $('scanQRBtn');
    const walletInput = $('walletInput'), networkSelect = $('networkSelect');
    const qrPreview = $('qrPreview');
    const debugBlock = $('debugBlock');
    const lightHashEl = $('lightHash');
    const timeClock = $('timeClock');

    // -------------------------
    // Rendering UI helpers
    // -------------------------
    function renderTokens(){
      rtNum.textContent = State.rt.toFixed(3);
      gtNum.textContent = State.gt.toFixed(3);
      btNum.textContent = State.bt.toFixed(3);
      balRT.textContent = State.rt.toFixed(3);
      balGT.textContent = State.gt.toFixed(3);
      balBT.textContent = State.bt.toFixed(3);
      lightHashEl.textContent = State.lightParts.join(' | ') || '—';
    }
    function renderDebug(){
      debugBlock.textContent = `running: ${State.running}\nwallet: ${State.wallet}\nnetwork: ${State.network}\nrt:${State.rt.toFixed(3)} gt:${State.gt.toFixed(3)} bt:${State.bt.toFixed(3)}\nlightParts:${State.lightParts.length}`;
    }

    // -------------------------
    // Token accumulation model
    // - Emulates sampling of display/frame averaged RGB in 16-bit range [0..65535]
    // - Converts to tokens with coefficient k and optional coherence factor
    // -------------------------
    function sampleRGB16(){
      // For demo: simulate video/reading by smooth random walk to produce believable color flows
      // Use Perlin-like simple noise via sine/cos with phase offsets
      const t = performance.now() * 0.00018; // slow evolving time
      const r = Math.floor( (Math.sin(t*1.1 + 0.2)*0.5+0.5) * 65535 );
      const g = Math.floor( (Math.sin(t*1.4 + 2.1)*0.5+0.5) * 65535 );
      const b = Math.floor( (Math.sin(t*1.7 + 4.0)*0.5+0.5) * 65535 );
      return {r,g,b,ts:Date.now()};
    }

    function allocateTokensFromRGB(rgb){
      const norm = 65535;
      const k = 0.01;            // conversion coefficient
      const addR = (rgb.r / norm) * k;
      const addG = (rgb.g / norm) * k;
      const addB = (rgb.b / norm) * k;
      State.rt += addR;
      State.gt += addG;
      State.bt += addB;

      // LightHash part: short signature derived from time + reduced RGB
      const t = computeQGTimeFromMs(Date.now());
      const sig = `${t.hour}-${t.part}-${Math.floor(rgb.r/256)}.${Math.floor(rgb.g/256)}.${Math.floor(rgb.b/256)}`;
      State.lightParts.push(sig);
      if(State.lightParts.length > 10) State.lightParts.shift();

      return {addR, addG, addB, sig};
    }

    // -------------------------
    // UI actions
    // -------------------------
    startBtn.addEventListener('click', ()=>{
      State.running = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;
      updateUIButtons();
    });
    stopBtn.addEventListener('click', ()=>{
      State.running = false;
      startBtn.disabled = false;
      stopBtn.disabled = true;
      updateUIButtons();
    });
    stopBtn.disabled = true;

    connectBtn.addEventListener('click', ()=>{
      if(State.wallet === 'anonymous'){
        const a = 'qg_' + Math.random().toString(36).slice(2,10);
        State.wallet = a;
        walletInput.value = a;
        connectBtn.textContent = 'Disconnect';
      } else {
        State.wallet = 'anonymous';
        walletInput.value = '';
        connectBtn.textContent = 'Connect Wallet';
      }
      renderDebug();
    });

    scanQRBtn.addEventListener('click', ()=>{
      // Demo: open file picker to select an image (pretend it's QR)
      const inp = document.createElement('input');
      inp.type = 'file';
      inp.accept = 'image/*';
      inp.onchange = (e)=>{
        const f = e.target.files && e.target.files[0];
        if(!f) return;
        const url = URL.createObjectURL(f);
        qrPreview.innerHTML = '';
        const img = document.createElement('img');
        img.src = url;
        img.style.maxWidth = '100%';
        img.style.maxHeight = '100%';
        img.style.borderRadius = '6px';
        qrPreview.appendChild(img);
        // For demo: fill wallet input with a fake address parsed from file name
        const fake = 'qg_' + Math.random().toString(36).slice(2,10);
        walletInput.value = fake;
        State.wallet = fake;
        connectBtn.textContent = 'Disconnect';
        renderDebug();
      };
      inp.click();
    });

    $('sendNowBtn').addEventListener('click', ()=>{
      // Simulate sending: take current accumulated tokens, "transfer" to address
      const to = walletInput.value.trim();
      const net = networkSelect.value;
      if(!to){
        alert('Введите адрес кошелька в поле Address (demo).');
        return;
      }
      // Make a "transfer object" but do not transmit (demo & anonymous)
      const transfer = {
        to, network: net,
        rt: State.rt, gt: State.gt, bt: State.bt,
        timestamp: qgTimeString()
      };
      // In demo we clear local session tokens and show alert
      State.rt = 0; State.gt = 0; State.bt = 0;
      State.lightParts = [];
      renderTokens();
      renderDebug();
      alert(`Demo send:\nTo: ${to}\nNetwork: ${net}\nTokens: RT ${transfer.rt.toFixed(3)}, GT ${transfer.gt.toFixed(3)}, BT ${transfer.bt.toFixed(3)}\n\nAll data anonymized (demo).`);
    });

    networkSelect.addEventListener('change', (e)=>{
      State.network = e.target.value;
      renderDebug();
    });

    // Reflect UI button states
    function updateUIButtons(){
      startBtn.disabled = State.running;
      stopBtn.disabled = !State.running;
    }

    // -------------------------
    // Three.js: iridescent glassy sphere + background particles + subtle FX
    // -------------------------
    const threeRoot = document.getElementById('threeRoot');
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(threeRoot.clientWidth || threeRoot.offsetWidth || window.innerWidth, threeRoot.clientHeight || threeRoot.offsetHeight || 600);
    threeRoot.appendChild(renderer.domElement);
    const camera = new THREE.PerspectiveCamera(45, renderer.domElement.clientWidth/renderer.domElement.clientHeight, 0.1, 1000);
    camera.position.set(0,0,6);

    // Responsive resize
    function resizeThree(){
      const w = threeRoot.clientWidth || window.innerWidth * 0.6;
      const h = threeRoot.clientHeight || window.innerHeight * 0.7;
      renderer.setSize(w,h);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resizeThree);
    resizeThree();

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.28);
    scene.add(ambient);
    const pLight1 = new THREE.PointLight(0xffe7d6, 1.2);
    pLight1.position.set(5,5,5);
    scene.add(pLight1);
    const pLight2 = new THREE.PointLight(0xcfefff, 0.9);
    pLight2.position.set(-5,-3,4);
    scene.add(pLight2);
    const rimLight = new THREE.PointLight(0xaaffff, 0.5);
    rimLight.position.set(0,4,-6);
    scene.add(rimLight);

    // Background particles (soft)
    const particlesCount = 220;
    const particlesGeom = new THREE.BufferGeometry();
    const positions = new Float32Array(particlesCount*3);
    const sizes = new Float32Array(particlesCount);
    for(let i=0;i<particlesCount;i++){
      positions[i*3+0] = (Math.random()-0.5)*20;
      positions[i*3+1] = (Math.random()-0.5)*12;
      positions[i*3+2] = (Math.random()-0.5)*12;
      sizes[i] = 0.6 + Math.random()*2.4;
    }
    particlesGeom.setAttribute('position', new THREE.BufferAttribute(positions,3));
    particlesGeom.setAttribute('size', new THREE.BufferAttribute(sizes,1));
    const particlesMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.12,
      transparent:true,
      opacity:0.06,
      depthWrite:false
    });
    const particles = new THREE.Points(particlesGeom, particlesMat);
    scene.add(particles);

    // Create glassy iridescent sphere using ShaderMaterial
    // Vertex shader: pass normal and uv
    const vertexShader = `
      varying vec3 vNormal;
      varying vec3 vPos;
      varying vec2 vUv;
      void main(){
        vUv = uv;
        vNormal = normalize(normalMatrix * normal);
        vPos = (modelViewMatrix * vec4(position,1.0)).xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `;

    // Fragment shader: iridescent sheen mapping based on angle + uv + time, plus glass transparency
    const fragmentShader = `
      precision highp float;
      uniform float uTime;
      uniform vec3 uBaseTint;
      uniform float uIor;
      uniform float uOpacity;
      varying vec3 vNormal;
      varying vec3 vPos;
      varying vec2 vUv;

      // convert hue [0..1] to rgb
      vec3 hue2rgb(float h){
        float r = abs(h * 6.0 - 3.0) - 1.0;
        float g = 2.0 - abs(h * 6.0 - 2.0);
        float b = 2.0 - abs(h * 6.0 - 4.0);
        return clamp(vec3(r,g,b), 0.0, 1.0);
      }

      void main(){
        vec3 N = normalize(vNormal);
        vec3 V = normalize(-vPos);

        // Fresnel-like factor
        float fresnel = pow(1.0 - max(dot(N,V), 0.0), 3.0);

        // iridescent hue mapped from view+normal+uv+time
        float angleFactor = dot(N, V) * 0.5 + 0.5;
        float t = uTime * 0.12;
        float hue = fract(t + vUv.x*0.4 + vUv.y*0.2 + angleFactor*0.6);
        hue += 0.12 * sin((vUv.x + t)*6.2831) + 0.08 * cos((vUv.y - t)*4.7124);
        hue = fract(hue);

        vec3 irid = hue2rgb(hue);

        // specular highlight
        vec3 R = reflect(-V, N);
        float spec = pow(max(dot(R, normalize(vec3(0.0,0.0,1.0))), 0.0), 24.0);

        // mix base tint with iridescence driven by fresnel
        vec3 color = mix(uBaseTint*0.5, irid, clamp(fresnel*1.6, 0.0, 1.0));
        color += vec3(spec*0.7);

        // alpha for glassy transparency
        float alpha = clamp(uOpacity * (1.0 - 0.6 * fresnel), 0.07, 0.92);

        // vignette by uv
        float v = smoothstep(0.9, 0.3, length(vUv - 0.5));
        color *= (0.92 + 0.08 * v);

        gl_FragColor = vec4(color, alpha);
      }
    `;

    const uniforms = {
      uTime: {value: 0},
      uBaseTint: {value: new THREE.Color(0.1,0.1,0.2)},
      uIor: {value: 1.45},
      uOpacity: {value: 0.72}
    };

    const sphereGeom = new THREE.SphereGeometry(1.6, 128, 128);
    const sphereMat = new THREE.ShaderMaterial({
      vertexShader, fragmentShader,
      uniforms,
      transparent: true,
      depthWrite: false,
      side: THREE.DoubleSide
    });
    const sphere = new THREE.Mesh(sphereGeom, sphereMat);
    scene.add(sphere);

    // thin glossy coat for extra sheen using MeshPhysicalMaterial overlay
    const coat = new THREE.Mesh(sphereGeom, new THREE.MeshPhysicalMaterial({
      color: 0xffffff,
      metalness: 0.0,
      roughness: 0.02,
      transmission: 0.0,
      opacity: 0.07,
      transparent: true,
      side: THREE.DoubleSide,
      depthWrite: false
    }));
    coat.scale.set(1.0012,1.0012,1.0012);
    scene.add(coat);

    // subtle floor reflection plane (fake, just for depth)
    const planeGeo = new THREE.CircleGeometry(6, 64);
    const planeMat = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.04});
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI/2;
    plane.position.y = -2.2;
    scene.add(plane);

    // animation loop
    let prevTime = performance.now();
    function animate(){
      const now = performance.now();
      const dt = (now - prevTime) / 1000;
      prevTime = now;

      // global time
      uniforms.uTime.value = now * 0.001;

      // continuous rotation (always rotate, regardless of running)
      const speedFactor = 1 + (State.rt + State.gt + State.bt) * 0.0012;
      sphere.rotation.y += 0.015 * speedFactor;
      sphere.rotation.x += 0.006 * speedFactor;
      coat.rotation.copy(sphere.rotation);
      plane.rotation.z += 0.0005; // slow drift

      // particles gentle movement
      const posAttr = particlesGeom.attributes.position;
      for(let i=0;i<particlesCount;i++){
        let idx = i*3;
        posAttr.array[idx+2] += 0.002 * Math.sin(now * 0.0005 + i);
        // wrap
        if(posAttr.array[idx+2] > 12) posAttr.array[idx+2] = -12;
      }
      posAttr.needsUpdate = true;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // -------------------------
    // Main tick: sampling + accumulation + UI update
    // -------------------------
    function mainTick(){
      // update clock text always
      timeClock.textContent = qgTimeString();

      if(State.running){
        const rgb = sampleRGB16();
        // allocate tokens
        allocateTokensFromRGB(rgb);
        // update shader base tint: subtle shifting based on token mix
        const maxVal = Math.max(State.rt, State.gt, State.bt, 1.0);
        const baseR = clamp(State.rt / maxVal * 0.9 + 0.08, 0.05, 1.0);
        const baseG = clamp(State.gt / maxVal * 0.9 + 0.08, 0.05, 1.0);
        const baseB = clamp(State.bt / maxVal * 0.9 + 0.08, 0.05, 1.0);
        uniforms.uBaseTint.value.set(baseR, baseG, baseB);
      } else {
        // when paused, slowly relax base tint to neutral
        const cur = uniforms.uBaseTint.value;
        cur.lerp(new THREE.Color(0.08,0.08,0.12), 0.02);
      }

      // update UI
      renderTokens();
      renderDebug();
      // schedule next tick
      // note: mainTick runs on interval below
    }

    // run mainTick at decent rate (250ms)
    setInterval(mainTick, 250);

    // initialize UI display
    renderTokens();
    renderDebug();

    // Expose simple debug API to console
    window.QG = {
      state: State,
      sampleRGB16,
      allocateTokensFromRGB,
      qgTimeString
    };

  })();
  </script>
</body>
</html>
